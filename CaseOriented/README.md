# 面向用例检测模块

## introduction

该模块启动后可以自动检测所有的提交，并且返回一个list，里面是所有有面向对象嫌疑的提交

检测完后会返回有嫌疑的提交的个数和总检测数，同时会返回一个`dict`，考虑到同学id和题目id的双重唯一性，`dict`中会以两个id的字符串拼接为索引，值为一个Case对象，对象中包含了大量的信息

```python
class Case:
    uploader = '' # 提交者的id
    case_id = '' # 题目id
    case_type = '' # 题目类型
    final_score = 0 # 最后得分
    upload_records = list() # 每次提交的得分
    main_ = list() # 每次提交的代码文件索引
```

助教可以随机抽查`dict`中的数据，然后查看某个同学在某个问题上所有的提交。

## Basic theory

本节会简单介绍面向用例检测模块的原理，在介绍前，我们需要在一些概念和名词以及表达方式上达成一致

- 后文将用`<userId>-<case_id>-<uploader_id>`这样的格式来标注出某人在某道题上的某次提交

### 出发点

我们先来看一个面向用例代码的例子

```python
nmst = input().split(' ')
num = int(nmst[1])
for i in range(num):
    input()
if nmst == ['250', '610', '204', '239']:
    print(1544)
elif nmst == ['100', '251', '88', '95']:
    print(969)
elif nmst == ['2000', '4862', '1935', '306']:
    print(1075)
elif nmst == ['2500', '6071', '1760', '669']:
    print(1159)
elif nmst == ['50', '122', '14', '3']:
    print(1215)
elif nmst == ['1000', '2450', '925', '987']:
    print(762)
elif nmst == ['7', '11', '5', '4']:
    print(7)
elif nmst == ['10', '20', '9', '4']:
    print(576)
elif nmst == ['20', '43', '11', '19']:
    print(491)
elif nmst == ['500', '1229', '5', '23']:
    print(1252)
else:
    print(nmst)
```

根据这个例子我们可以观察出这样的几个事实：

- 面向用例编程可能会产生大量的if-else
- 面向用例编程可能需要获得所有的输入
- 面向用例编程可能会直接输出结果

### 基于输出的面向用例检测

基于第三个事实，我们做出了一个非常严苛的面向用例检测代码，其中核心代码如下

```python
out_ = case['output']
outs = out_.split('\n')
    for _ in outs:
        if _ == '':
            continue
        for __ in prints:
            if _ in __:
                count += 1
                print(_+" "+__)
                break
```

这段代码会将代码里面所有的`print`函数提取出来，然后检测被print的数据是否含有正确答案。为什么我们要使用这样的方法呢？原因很简单，我们的在线测评系统完全是通过`print`函数来打印答案，然而很多题目的答案往往不会是一个常量。如果你在答案中打印出来一个常量，那么我们认为你有面向用例的嫌疑。当然，对于一些比较简单的题目，往往答案就是True或者False，所以大家最后也会在`print`函数中写个True或者False。这部分内容在后面讲，下面我们讨论一下基于第二个事实是否可以正确的检测出面向用例

### 基于输入的面向用例检测

在基于面向用例的检测之后，我们核对了所有有面向用例嫌疑的例子，在48117-2081-249325提交中出现了这样的代码，分数为100分

```python
a = input()
b = input()
a.lower()
b.lower()
if a.count(b) == 2:
    print(3, end='')
else:
    print(a.count(b), end='')
```

在讨论是否这段代码是否面向用例之前，我们来看一下题目

> ### 题目描述
>
> 这是一道模板题。
>
> 给定一个字符串` A`和一个字符串`  B` ，求` B` 在`  A`中的出现次数。` A` 和` B` 中的字符均为英语大写字母或小写字母。
>
>  ` A` 中不同位置出现的` B` 可重叠。
>
> ### 输入描述
>
> > 输入共两行，分别是字符串` A`和字符串`  B` 。
>
> ### 输出描述
>
> > 输出一个整数，表示 ` A` 在` B` 中的出现次数。
>
> ### 测试样例
>
> 样例1：输入-输出-解释
>
> ```
> zyzyzyz
> zyz
> ```
>
> ```
> 3
> ```
>
> ### 数据范围与提示
>
> > 1<=` A,B的长度` <=100000，` A、B` 仅包含大小写字母

在这次提交中，我们可以分析出写作业的人没有考虑到字符串重合的问题，直接使用了`count`函数来判断一个字符串在另一个字符串中出现的次数，官方文档中对这个函数的描述是这样的

> `str.count`(*sub*[, *start*[, *end*]])
>
> Return the number of non-overlapping occurrences of substring *sub* in the range [*start*, *end*]. Optional arguments *start* and *end* are interpreted as in slice notation.

其中指出了这个方法只针对`non-overlapping`。因此，我们可以判断出来，在这次提交中，虽然提交者并没有将输入直接放到答案里面，但是提交者靠着对输入用例的分析，成功找到了输入的一些特点，那就是只有一个用例是有字符串重合的情况，其他的用例都是不重合了。

这个例子给了我们启发，那就是面向用例或许不一定需要直接将用例的输入写出来，而是可以结合题目，合理分析用例的结构，进而通过取巧的方式输出答案。另一方面，在`json`文件中的输入和真正转换到python中可以使用的变量的时候，用例的输入已经发生了变化，可能从字符串变成了一个列表。不过对于大部分题目而言，检测输入是否存在于代码中还是非常好用的。但是我们注意到，如果输入中存在一些1，0，或者同学们经常使用的常量的时候，那就很容易发生误判了。

总的来说，不管是基于输出还是基于输入，他们在非常简单的情况下都会失效，因此在使用的时候需要仔细甄别，我们也在检测环节打印出了被检测到的输入输出来辅助助教进行判断。

