# 面向用例检测模块

## introduction

该模块启动后可以自动检测所有的提交，并且返回一个list，里面是所有有面向对象嫌疑的提交

检测完后会返回有嫌疑的提交的个数和总检测数，同时会返回一个`dict`，考虑到同学id和题目id的双重唯一性，`dict`中会以两个id的字符串拼接为索引，值为一个Case对象，对象中包含了大量的信息

```python
class Case:
    uploader = '' # 提交者的id
    case_id = '' # 题目id
    case_type = '' # 题目类型
    final_score = 0 # 最后得分
    upload_records = list() # 每次提交的得分
    match_records = dict() # 检测信息
```

助教可以随机抽查`dict`中的数据，然后查看某个同学在某个问题上所有的提交。

## Basic theory

本节会简单介绍面向用例检测模块的原理，在介绍前，我们需要在一些概念和名词以及表达方式上达成一致

- 后文将用`<userId>-<case_id>-<uploader_id>`这样的格式来标注出某人在某道题上的某次提交

### 出发点

我们先来看一个面向用例代码的例子

```python
nmst = input().split(' ')
num = int(nmst[1])
for i in range(num):
    input()
if nmst == ['250', '610', '204', '239']:
    print(1544)
elif nmst == ['100', '251', '88', '95']:
    print(969)
elif nmst == ['2000', '4862', '1935', '306']:
    print(1075)
elif nmst == ['2500', '6071', '1760', '669']:
    print(1159)
elif nmst == ['50', '122', '14', '3']:
    print(1215)
elif nmst == ['1000', '2450', '925', '987']:
    print(762)
elif nmst == ['7', '11', '5', '4']:
    print(7)
elif nmst == ['10', '20', '9', '4']:
    print(576)
elif nmst == ['20', '43', '11', '19']:
    print(491)
elif nmst == ['500', '1229', '5', '23']:
    print(1252)
else:
    print(nmst)
```

根据这个例子我们可以观察出这样的几个事实：

- 面向用例编程可能会产生大量的if-else
- 面向用例编程可能需要获得所有的输入
- 面向用例编程可能会直接输出结果

### 基于输出的面向用例检测

基于第三个事实，我们做出了一个非常严苛的面向用例检测代码，其中核心代码如下

```python
out_ = case['output']
outs = out_.split('\n')
    for _ in outs:
        if _ == '':
            continue
        for __ in prints:
            if _ in __:
                count += 1
                print(_+" "+__)
                break
```

这段代码会将代码里面所有的`print`函数提取出来，然后检测被print的数据是否含有正确答案。为什么我们要使用这样的方法呢？原因很简单，我们的在线测评系统完全是通过`print`函数来打印答案，然而很多题目的答案往往不会是一个常量。如果你在答案中打印出来一个常量，那么我们认为你有面向用例的嫌疑。当然，对于一些比较简单的题目，往往答案就是True或者False，所以大家最后也会在`print`函数中写个True或者False。这部分内容在后面讲，下面我们讨论一下基于第二个事实是否可以正确的检测出面向用例

### 基于输入的面向用例检测

在基于面向用例的检测之后，我们核对了所有有面向用例嫌疑的例子，在48117-2081-249325提交中出现了这样的代码，分数为100分

```python
a = input()
b = input()
a.lower()
b.lower()
if a.count(b) == 2:
    print(3, end='')
else:
    print(a.count(b), end='')
```

在讨论是否这段代码是否面向用例之前，我们来看一下题目

> ### 题目描述
>
> 这是一道模板题。
>
> 给定一个字符串` A`和一个字符串`  B` ，求` B` 在`  A`中的出现次数。` A` 和` B` 中的字符均为英语大写字母或小写字母。
>
>  ` A` 中不同位置出现的` B` 可重叠。
>
> ### 输入描述
>
> > 输入共两行，分别是字符串` A`和字符串`  B` 。
>
> ### 输出描述
>
> > 输出一个整数，表示 ` A` 在` B` 中的出现次数。
>
> ### 测试样例
>
> 样例1：输入-输出-解释
>
> ```
> zyzyzyz
> zyz
> ```
>
> ```
> 3
> ```
>
> ### 数据范围与提示
>
> > 1<=` A,B的长度` <=100000，` A、B` 仅包含大小写字母

在这次提交中，我们可以分析出写作业的人没有考虑到字符串重合的问题，直接使用了`count`函数来判断一个字符串在另一个字符串中出现的次数，官方文档中对这个函数的描述是这样的

> `str.count`(*sub*[, *start*[, *end*]])
>
> Return the number of non-overlapping occurrences of substring *sub* in the range [*start*, *end*]. Optional arguments *start* and *end* are interpreted as in slice notation.

其中指出了这个方法只针对`non-overlapping`。因此，我们可以判断出来，在这次提交中，虽然提交者并没有将输入直接放到答案里面，但是提交者靠着对输入用例的分析，成功找到了输入的一些特点，那就是只有一个用例是有字符串重合的情况，其他的用例都是不重合了。

这个例子给了我们启发，那就是面向用例或许不一定需要直接将用例的输入写出来，而是可以结合题目，合理分析用例的结构，进而通过取巧的方式输出答案。另一方面，在`json`文件中的输入和真正转换到python中可以使用的变量的时候，用例的输入已经发生了变化，可能从字符串变成了一个列表。不过对于大部分题目而言，检测输入是否存在于代码中还是非常好用的。但是我们注意到，如果输入中存在一些1，0，或者同学们经常使用的常量的时候，那就很容易发生误判了。

针对输入用例进行算法修改后，我们的核心代码变成了下面这样

```python
in_ = case['input']
ins = in_.split('\n')
for _ in ins:
    if _ == '':
        continue
    for __ in lines:
        if _ in __:
            ic += 1
            si_ += _ + ' ' + __ + '\n'
            break

out_ = case['output']
outs = out_.split('\n')
for _ in outs:
    if _ == '':
        continue
    for __ in prints:
        if _ in __:
            oc += 1
            so_ += _ + " " + __ + "\n"
            break
```

总的来说，不管是基于输出还是基于输入，他们在非常简单的情况下都会失效，因此在使用的时候需要仔细甄别，我们也在检测环节打印出了被检测到的代码片段来帮助助教进行判断。

### 关于if-else大量出现

我们不打算在代码中直接分析if-else的数量和级联情况，因为他对我们检测的性能有很大的折损

> TODO

我们认为，if-else的大量出现反应了另一个事实，那就是大部分学生往往需要多次的提交、实验，才能获取所有的用例，因此我们总结出了另一个重要的检测指标，那就是提交次数。当然并不是提交次数多就一定是面向用例编程，他有可能提交了很多次只是因为找不到bug，也有可能是因为用例太少而不需要多次的提交实验。但是我们认为这是一个比较直观的判断的依据。

## 如何辅助检测？

在上文中，我们提到了很多数据和指标，但是因为数据和指标比较多，展示的时候将会有一些优先级，不然会降低助教判断代码面向用例的效率。我们的数据展示的顺序将会是以下顺序

```
1· 有嫌疑的提交次数和总提交次数
2. 所有有嫌疑的提交中他们的[提交者id， 题目id， 在该题上的提交次数]将会被打印出来，以提交次数和用例数的比值进行从大到小的排序。
3. 助教可以选择提交者id， 题目id来查看他在本题上所有提交的编号，以及每次提交的分数，哪些提交是有面向用例嫌疑的
4. 指定编号后可以查看在这个提交中被判断有嫌疑的那些<用例，代码>对和具体的代码
```

