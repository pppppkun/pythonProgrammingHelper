# 面向用例检测模块

## introduction

该模块启动后可以自动检测所有的提交，并且返回一个list，里面是所有有面向对象嫌疑的提交

检测完后会返回有嫌疑的提交的个数和总检测数，同时会返回一个`dict`，考虑到同学id和题目id的双重唯一性，`dict`中会以两个id的字符串拼接为索引，值为一个Case对象，对象中包含了大量的信息

```python
class Case:
    uploader = '' # 提交者的id
    case_id = '' # 题目id
    case_type = '' # 题目类型
    final_score = 0 # 最后得分
    upload_records = list() # 每次提交的得分
    main_ = list() # 每次提交的代码文件索引
```

助教可以随机抽查`dict`中的数据，然后查看某个同学在某个问题上所有的提交。

## Basic theory

本节会简单介绍面向用例检测模块的原理，在介绍前，我们需要在概念上达成一致

- 

### 出发点

我们先来看一个面向用例代码的例子

```python
nmst = input().split(' ')
num = int(nmst[1])
for i in range(num):
    input()
if nmst == ['250', '610', '204', '239']:
    print(1544)
elif nmst == ['100', '251', '88', '95']:
    print(969)
elif nmst == ['2000', '4862', '1935', '306']:
    print(1075)
elif nmst == ['2500', '6071', '1760', '669']:
    print(1159)
elif nmst == ['50', '122', '14', '3']:
    print(1215)
elif nmst == ['1000', '2450', '925', '987']:
    print(762)
elif nmst == ['7', '11', '5', '4']:
    print(7)
elif nmst == ['10', '20', '9', '4']:
    print(576)
elif nmst == ['20', '43', '11', '19']:
    print(491)
elif nmst == ['500', '1229', '5', '23']:
    print(1252)
else:
    print(nmst)
```

根据这个例子我们可以观察出这样的几个事实：

- 面向用例编程可能会产生大量的if-else
- 面向用例编程可能需要获得所有的输入
- 面向用例编程可能会直接输出结果

### 基于输出的面向用例检测

基于第三个事实，我们做出了一个非常严苛的面向用例检测代码，其中核心代码如下

```python
out_ = case['output']
outs = out_.split('\n')
    for _ in outs:
        if _ == '':
            continue
        for __ in prints:
            if _ in __:
                count += 1
                print(_+" "+__)
                break
```

这段代码会将代码里面所有的`print`函数提取出来，然后检测被print的数据是否含有正确答案。为什么我们要使用这样的方法呢？原因很简单，我们的在线测评系统完全是通过`print`函数来打印答案，然而很多题目的答案往往不会是一个常量。如果你在答案中打印出来一个常量，那么我们认为你有面向用例的嫌疑。当然，对于一些比较简单的题目，往往答案就是True或者False，所以大家最后也会在`print`函数中写个True或者False。这部分内容在后面讲，下面我们讨论一下基于第二个事实是否可以正确的检测出面向用例

### 基于输入的面向用例检测

