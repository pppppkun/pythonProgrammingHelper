# 题目推荐系统

## introduction

对于编程新手来说，我们认为提供针对性的训练是非常重要的，因为对于新人来说，如果各个方面都浅尝则止，那么他将没有办法体会到不同类型题目的特点和套路。因此，我们设计了题目推荐系统，并且参考了比较流行的几个推荐系统模型（Matrix Factorization Techniques for Recommender Systems）。
在数据预处理阶段，我们为了方便后面推荐系统模型的训练，将user_id和case_id分别映射到从0开始的序列，同时因为test_data包含所有sample的数据，所以由test_data构造出来的矩阵包括了sample的内容，基于此，我们可以将test_data中的80%作为训练集，20%作为测试集。

在训练阶段，我们选择了BiasSVD作为模型，并且在Google提供的colab上进行训练，最后的结果为使用RMSE进行评估，结果为10.7595，我们认为这个结果是可以接受的

## Theory

在开始之前，我们先规定一下后文中使用到的一些变量
$$
M_{mn} \text{表示一个m行，n列的矩阵，矩阵里的每一个元素表示第m个用户在第n道题目上的得分} \\
e_{ui} \text{表示第u个用户在第i道题上的预测分数和实际分数的偏差} \\
Q_{mk} \text{表示一个m行，k列的矩阵，其中每行都表示一个用户，每列表示题目不同的特征} \\
P_{nk} \text{表示一个n行，k列的矩阵，其中每行表示一个题目，每列表示题目不同的特征}
$$


虽然最基础和最流行的机器学习推荐系统模型是协同过滤模型，但是我们都知道，如果使用协同过滤模型，在user和case两个矩阵中，他们的列都是题目的特征，它训练的公式为
$$
e_{ui} = m_{ui} -q_{u}p^T_i
$$
但是这个模型忽略了一件事情，那就是不同用户在不同题目上的表现其实不能完全由一个题目的特征决定。为什么呢？我们先从电影推荐这个例子来考虑，如果泰坦尼克号的分数为5分，但是因为这部电影比较经典，在所有电影里面排名比较前，用户给他打分的时候会多打几分。但是如果一个用户比较具有批判心理，那么他会倾向于给电影打一个比平均分稍微低一点的分数。同样的，有部分同学水平可能特别高，那么这部分同学所做的题目的特征就会带上这部分同学的印记，他们会呈现出一种系统性的趋势，也会有一部分题目可能天生就会得到比别的题目更高的分数，又或者有一部分题目的翻译有问题（这个是真实存在的问题），这部分题目的得分可能会表现出低于同类型题目的倾向。在这里我们认为题目的特征仅仅是题目的分类，不包括题目的难度。因此我们选择了BiasSVD作为我们的训练模型。我们引入几个新的变量
$$
b_{ui} \text{表示偏差在}m_{ui}\text{上的贡献}\\
b_u \text{表示用户u的偏差} \\
b_i \text{表示题目i的偏差} \\
\mu \text{平均分数}
$$
所以最后我们训练的公式为
$$
e_{ui} = m_{ui} -q_{u}p^T_i - b_{ui} \\
b_{ui} = b_u+b_i +\mu
$$
在编码上来说，BiasSVD是比较简单的，所以我们认为这个算法集中了便捷性和适用性。

最后，因为我们是矩阵分解算法，所以我们一开始并不知道题目的特征是多少，这个我们交给了模型自己来训练，尽管在数据中是包含了题目的特征的，但是数据中的特征相对来说比较局限，比如字符串中又可以分出动态规划+字符串，或者自动机+字符串等。所以我们选择了k=15来进行训练。

## Result

最后我们使用了RMSE来进行评估
$$
RMSE(H,X) = \sqrt{\frac{1}{m}\sum_{i=1}^m(h(x_i)-y_i)^2}
$$
他常用来作为机器学习模型预测结果衡量的标准。在RMSE下我们的结果为10.7595，我们认为这个结果是可以接受的。因为RMSE衡量了所有偏差的平均值。这表明我们所有的预测出来的结果和真实值的差距只有10分，如果这道题的用例有10个，那么相当于只错了1个用例，如果用例有5个，相当于有一半的概率多做对或者多错一个用例。这表明我们的预测和实际情况已经非常接近了。

根据我们的结果重新计算一轮，然后对每个用户都按照题目的得分从小到大排序，从这个序列中，我们需要进一步考虑推荐的策略。这里我们给出一个比较简单但是实用的策略

- 首先计算和最低分题目特征欧式距离最短的题目，这些题目和最低分题目是类型比较接近的
- 其次在这些题目里我们按照题目难度和用户在这些题目上的最终得分进行排序
- 最后我们再选出最适合用户的题目

